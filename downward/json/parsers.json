{
    "solved": {
        "regex": "search exit code: (-?\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "optimal": {
        "regex": "Plan cost: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "infeasible": {
        "regex": "search exit code: (-?\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "timeout": {
        "regex": "search exit code: (-?\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "memout": {
        "regex": "search exit code: (-?\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "cplex_exception": {
        "regex": "search exit code: (-?\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "solution_not_found": {
        "regex": "search exit code: (-?\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "other_error": {
        "regex": "search exit code: (-?\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "quality_score": {
        "regex": "Best bound found: (\\d+\\.?\\d*)",
        "type": "float",
        "summary": "sum"
    },
    "best_bound": {
        "regex": "Best bound found: (\\d+\\.?\\d*)",
        "type": "float",
        "summary": "sum"
    },
    "plan_length": {
        "regex": "Plan length: (\\d+\\.?\\d*) step\\(s\\)\\.",
        "type": "int",
        "summary": "mean"
    },
    "plan_cost": {
        "regex": "Plan cost: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "optimal_plan_cost": {
        "regex": "search exit code: (-?\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "perc_astar_is_better": {
        "regex": "Perc astar is better: (\\d+\\.?\\d*)",
        "type": "float",
        "summary": "mean"
    },
    "min_plan_in_cache": {
        "regex": "Min plan in cache: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "max_f_equals_optimal_plan_cost": {
        "regex": "Max f found: (\\d+\\.?\\d*)|f = (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "seqs": {
        "regex": "Number of seqs: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "repeated_seqs": {
        "regex": "Repeated seqs: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "seqs_solved": {
        "regex": "Number of seqs: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "repeated_seqs_solved": {
        "regex": "Repeated seqs: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "restarts": {
        "regex": "Restarts: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "total_astar_time": {
        "regex": "Total astar time: (\\d+\\.?\\d*)s",
        "type": "float",
        "summary": "mean"
    },
    "total_solve_time": {
        "regex": "Total solve time: (\\d+\\.?\\d*)s|t=(\\d+\\.?\\d*)s",
        "type": "float",
        "summary": "mean"
    },
    "planner_memory": {
        "regex": "Peak memory: (\\d+\\.?\\d*) KB",
        "type": "int",
        "summary": "mean"
    },
    "last_nodes_expanded": {
        "regex": "Last nodes expanded: (\\d+\\.?\\d*)|(\\d+\\.?\\d*) expanded",
        "type": "int",
        "summary": "mean"
    },
    "last_astar_time": {
        "regex": "Last astar time: (\\d+\\.?\\d*)",
        "type": "float",
        "summary": "mean"
    },
    "max_op_count": {
        "regex": "Max op count: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "max_num_ops": {
        "regex": "Max num ops: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "max_num_distinct_ops": {
        "regex": "Max num distinct ops: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "max_op_count_solved": {
        "regex": "Max op count: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "max_num_ops_solved": {
        "regex": "Max num ops: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "max_num_distinct_ops_solved": {
        "regex": "Max num distinct ops: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "max_f_found": {
        "regex": "Max f found: (\\d+\\.?\\d*)|f = (\\d+\\.?\\d*)",
        "type": "float",
        "summary": "mean"
    },
    "ops": {
        "regex": "Number of ops: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "variables": {
        "regex": "Number of variables: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "mean_ops_by_constraint": {
        "regex": "Mean ops by constraint: (\\d+\\.?\\d*)",
        "type": "float",
        "summary": "mean"
    },
    "median_ops_by_constraint": {
        "regex": "Median ops by constraint: (\\d+\\.?\\d*)",
        "type": "float",
        "summary": "mean"
    },
    "last_ops_by_constraint": {
        "regex": "Last ops by constraint: (\\d+\\.?\\d*)",
        "type": "float",
        "summary": "mean"
    },
    "mean_lp_added_constraints": {
        "regex": "Mean LP added constraints: (\\d+\\.?\\d*)",
        "type": "float",
        "summary": "mean"
    },
    "last_lp_added_constraints": {
        "regex": "Last LP added constraints: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "times_made_progress": {
        "regex": "Times made progress: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "mean_nodes_expanded": {
        "regex": "Mean nodes expanded: (\\d+\\.?\\d*)",
        "type": "float",
        "summary": "mean"
    },
    "initial_lp_solution": {
        "regex": "Initial LP solution: (\\d+\\.?\\d*)",
        "type": "float",
        "summary": "mean"
    },
    "max_lp_solution": {
        "regex": "Max LP solution: (\\d+\\.?\\d*)",
        "type": "float",
        "summary": "mean"
    },
    "total_pre_lp_time": {
        "regex": "Total pre LP time: (\\d+\\.?\\d*)s",
        "type": "float",
        "summary": "mean"
    },
    "total_lp_time": {
        "regex": "Total LP time: (\\d+\\.?\\d*)s",
        "type": "float",
        "summary": "mean"
    },
    "sat_n_vars": {
        "regex": "SAT n vars: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "sat_n_clauses": {
        "regex": "SAT n clauses: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "any_zero_cost_ops": {
        "regex": "Any zero cost ops: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "all_unit_cost_ops": {
        "regex": "All unit cost ops: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    },
    "min_op_cost": {
        "regex": "Min op cost: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "max_op_cost": {
        "regex": "Max op cost: (\\d+\\.?\\d*)",
        "type": "int",
        "summary": "mean"
    },
    "exit_code": {
        "regex": "search exit code: (-?\\d+\\.?\\d*)",
        "type": "int",
        "summary": "sum"
    }
}
